import { TargetResolver, Transition, Variants, Target, TargetAndTransition, TargetWithKeyframes } from "../types";
import { VariantLabels, MotionProps } from "../motion/types";
import { VisualElement } from "../render/VisualElement";
export declare type AnimationDefinition = VariantLabels | TargetAndTransition | TargetResolver;
declare type AnimationOptions = {
    delay?: number;
    priority?: number;
    transitionOverride?: Transition;
    custom?: any;
};
export declare type ReadValueFromSource = (key: string) => number | string;
export declare type MakeTargetAnimatable = (visualElement: VisualElement, target: TargetWithKeyframes, origin?: Target, transitionEnd?: Target) => {
    target: TargetWithKeyframes;
    origin?: Target;
    transitionEnd?: Target;
};
export interface AnimationControlsConfig {
    makeTargetAnimatable?: MakeTargetAnimatable;
}
/**
 * Control animations for a single component
 *
 * @internal
 */
export declare class VisualElementAnimationControls<P extends {} = {}, V extends {} = {}> {
    private visualElement;
    /**
     * A reference to the component's latest props. We could probably ditch this in
     * favour to a reference to the `custom` prop now we don't send all props through
     * to target resolvers.
     */
    private props;
    /**
     * The default transition to use for `Target`s without any `transition` prop.
     */
    private defaultTransition?;
    /**
     * The component's variants, as provided by `variants`
     */
    private variants;
    /**
     * A set of values that we animate back to when a value is cleared of all overrides.
     */
    private baseTarget;
    /**
     * A series of target overrides that we can animate to/from when overrides are set/cleared.
     */
    private overrides;
    /**
     * A series of target overrides as they were originally resolved.
     */
    private resolvedOverrides;
    /**
     * A Set of currently active override indexes
     */
    private activeOverrides;
    /**
     * A Set of children component controls for variant propagation.
     */
    private children?;
    /**
     * A Set of value keys that are currently animating.
     */
    private isAnimating;
    /**
     * A chance
     */
    private makeTargetAnimatable;
    constructor(visualElement: VisualElement, { makeTargetAnimatable }: AnimationControlsConfig);
    /**
     * Set the reference to the component's props.
     * @param props -
     */
    setProps(props: P & MotionProps): void;
    /**
     * Set the reference to the component's variants
     * @param variants -
     */
    setVariants(variants?: Variants): void;
    /**
     * Set the component's default transition
     * @param transition -
     */
    setDefaultTransition(transition?: Transition): void;
    /**
     * Set motion values without animation.
     *
     * @param definition -
     * @param isActive -
     */
    private setValues;
    /**
     * Allows `transformValues` to be set by a component that allows us to
     * transform the values in a given `Target`. This allows Framer Library
     * to extend Framer Motion to animate `Color` variables etc. Currently we have
     * to manually support these extended types here in Framer Motion.
     *
     * @param values -
     */
    private transformValues;
    /**
     * Check a `Target` for new values we haven't animated yet, and add them
     * to the `MotionValueMap`.
     *
     * Currently there's functionality here that is DOM-specific, we should allow
     * this functionality to be injected by the factory that creates DOM-specific
     * components.
     *
     * @param target -
     */
    private checkForNewValues;
    /**
     * Check if the associated `VisualElement` has a key with the provided string.
     * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.
     */
    private hasValue;
    /**
     * Resolve a variant from its label or resolver into an actual `Target` we can animate to.
     * @param variant -
     */
    private resolveVariant;
    /**
     * Get the highest active override priority index
     */
    private getHighestPriority;
    /**
     * Set an override. We add this layer of indirection so if, for instance, a tap gesture
     * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the
     * hover gesture, if that hover gesture has changed in the meantime we can go to that rather
     * than the one that was resolved when the hover gesture animation started.
     *
     * @param definition -
     * @param overrideIndex -
     */
    setOverride(definition: AnimationDefinition, overrideIndex: number): void;
    /**
     * Start an override animation.
     * @param overrideIndex -
     */
    startOverride(overrideIndex: number): Promise<void> | undefined;
    /**
     * Clear an override. We check every value we animated to in this override to see if
     * its present on any lower-priority overrides. If not, we animate it back to its base target.
     * @param overrideIndex -
     */
    clearOverride(overrideIndex: number): void;
    /**
     * Apply a target/variant without any animation
     */
    apply(definition: AnimationDefinition): void;
    /**
     * Apply variant labels without animation
     */
    private applyVariantLabels;
    start(definition: AnimationDefinition, opts?: AnimationOptions): Promise<void>;
    private animate;
    private animateVariantLabels;
    private animateVariant;
    private animateChildren;
    private onStart;
    private onComplete;
    private checkOverrideIsAnimating;
    private resetIsAnimating;
    stop(): void;
    /**
     * Add the controls of a child component.
     * @param controls -
     */
    addChild(controls: VisualElementAnimationControls): void;
    removeChild(controls: VisualElementAnimationControls): void;
    resetChildren(): void;
}
export {};
